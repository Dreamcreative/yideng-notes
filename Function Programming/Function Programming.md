# 函数式编程
函数式编程式是范畴论的数学分支,是一门很复杂的数学。范畴论认为,同一个范畴的所有成员就是不同状态的"变形"("态射").通过"态射“,一个成员可以变形成另一个成员
1. 函数是"第一等公民"
2. 只用"表达式"，"不用语句"
3. 没有"副作用"
4. 不修改状态
5. 引用透明(函数运行只靠参数)
## 内容
1. 所有成员是一个集合
2. 变形(态射)关系是函数
## 基础理论
1. 基础模型来源于 (lambda x=>x*2) 
2. 函数式编程不是用函数来编程,也不是传统的面向过程编程。主旨在于将复杂的函数复合成简单的函数.
3. 真正的火热是随着React 的高阶函数而逐步升温
## 常用核心概念
1. 纯函数
    1. 对于相同的输入,永远会得到相同的输出,而且没有任何可观察的副作用,也不依赖外部环境的状态
    纯函数 : Array.slice()
    2. 纯函数不仅可以有效降低系统的复杂度,还有其他特性,比如可缓存性 
2. 偏应用函数、函数的柯里化
    1. 传递给函数一部分参数来调用它,让他返回一个函数去处理剩下的参数
    2. 偏函数之所以"偏",就在于其职能处理那些能至少匹配一种情况下的输入,而不能处理所以可能的输入(switch case .就是一次只处理一种case)
        var _bind = fn.bind(null,2,3),bind就是一种函数柯里化
    3. 柯里化 通过偏应用函数实现.传递给函数一部分参数来调用它,让他返回一个函数去处理剩下的参数
    ```
    function foo(p1,p2){
        this.val = p1+p2;
    }
    var bar = foo.bind(null ,"p1");
    var baz = new bar("p2")
    console.log(baz.val)
    ```
    4. 柯里化是一种"预加载"函数的方法,通过传递较少的参数,得到一个已经记住了这些参数的新函数,某种意义上讲,这是一种对参数的"缓存", 是一种非常搞笑的编写函数的方法
3. 函数组合
4. point free
    存储中间逻辑,减少毫无意义的变量
5. 声明式与命令式代码
    1. 命令式: 通过编写一条又一条指令去执行一些动作,会设计到很多繁杂的细节
    2. 声明式 : 通过写表达式的方式来声明我们想干什么,而不是通过一步一步的指示(使用的函数必须是纯函数)
    ```
    //命令式
    let ceo = [];
    for(var i =0;i<10;i++>){
        ceo.push(i)
    }
    //声明式
    let ceo=arr.map(item=>item.ceo)
    ```
6. 惰性求值