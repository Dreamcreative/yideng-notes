# http 协议

## 浏览器行为与 http 协议

![http请求模型](../images/http请求模型.png)

- 处理流程

1. 输入网址并回车
2. 解析域名
3. 浏览器发送 http 请求
4. 服务器处理请求
5. 服务器返回 HTML 响应
6. 浏览器处理 HTML 页面
7. 继续请求其他资源

- 发送请求前：先跨越内外网的限制(互联网是外网,家里或者局域网属于内网)路由器或者是家用的猫(遵循一种 ppp 协议)
- 打开浏览器输入网址：将网址翻译成 ip 地址(解析域名),通过 DNS 服务器,找到真正要访问的 IP 地址
- 进行请求后：到了服务器机群,多个服务器共用一个 IP(通过反向代理完成)
- 服务器响应：
- 浏览器收到返回数据：浏览器渲染 HTML 页面

## 什么是 http 协议(超文本传输协议,从 www 服务器传输到本地浏览器的一种传输协议)

![http协议发展](../images/http协议发展.png)

- http 协议是由从客户端到服务器的请求和从服务器到客户端的响应进行约束和规范
  ![TCPIP协议栈](../images/TCPIP协议栈.png)

1. 应用层：为用户提供所需要的各种服务(HTTP,FTP,DNS,SMTP 等)
2. 传输层：
   - 传输控制协议(TCP)：一种靠谱的协议,只要它负责的就一定会完成
   - 用户数据报协议(UDP)：一种不靠谱协议 ,只负责发送,不管内容发没发到它不管
3. 网络层：解决主机到主机的通信问题
4. 网络接口层：负责监视数据在主机和网络之间的交换

- http 默认端口 80,https 默认端口 443

## HTTP 的工作过程

- 一次 HTTP 操作称为一个事务,其工作过程可分为四步：(事务表示一系列事情是串行完成,其中一步失败,这次操作就算失败)

1. 首先客户端与服务器需要建立连接
2. 建立连接后,客户端发送一个请求给服务器
3. 服务器接到请求后,给予相应的响应信息
4. 客户端接收服务器返回的信息通过浏览器显示在显示屏上(浏览器的渲染),然后客户端与服务器断开连接,如果不断开连接会产生一系列的问题

## 请求和响应

![http请求格式](../images/http请求格式.png)

1. HTTP 请求组成：请求行、消息报头、请求正文

- 请求行组成：以一个方法符号开头,后面跟着请求的 URI 和协议版本
  ![http请求组成](../images/http请求组成.png)

2. HTTP 响应组成：状态行、消息报头、响应正文

- 状态行组成：服务器 HTTP 协议的版本,服务器返回的响应状态码和状态码的文本描述
  ![http响应组成](../images/http响应组成.png)
  ![http响应组成2](../images/http响应组成2.png)

- http 是纯文本协议。与之对应的是二进制协议(http2 使用二进制协议)

## 请求方法

1. GET: 请求获取 Request-URI 所标识的资源 (GET 方法不附加请求体)
2. POST: 在 Request-URI 所标识的资源后附加新的数据 (POST 方法会附加请求体)
3. HEAD: 请求获取由 Request-URI 所标识的资源的响应消息报头
4. PUT: 请求服务器存储一个资源，并用 Request-URI 作为其标识
5. DELETE: 请求服务器删除 Request-URI 所标识的资源
6. TRACE: 请求服务器回送收到的请求信息，主要用于测试或诊断
7. CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
8. OPTIONS: 请求查询服务器的性能，或者查询与资源相关的选项和需求

## HTTP 状态码

1. 1xx:指示信息--表示请求已接收,继续处理
2. 2xx:成功--表示请求已被成功接收、理解、接收
   1. 200:表示从客户端发来的请求在服务器端被正常处理(OK)
   2. 204:表示服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分(No Content)
   3. 206:表示客户端进行了范围请求,而服务器成功执行了这部分的 GET 请求(Partial Content)
3. 3xx:重定向--要完成请求必须进行更进一步的操作
   1. 301:永久重定向(Moved Permanently)
   2. 302:临时重定向(Moved Temporarily)
4. 4xx:客户端错误--请求语法错误或请求无法实现
   1. 400: 表示请求报文中存在语法错误(Bad Request)
   2. 401:表示发送的请求需要有通过 HTTP 认证的认证信息(Unauthorized)
   3. 403:表示对请求资源的访问被服务器拒绝了(Forbidden)
   4. 404:表示服务器上无法找到请求的资源 (Not Found)
5. 5xx:服务器错误--服务器未能实现合法的请求
   1. 500:表示服务器端在执行请求是发生了错误(Internal Server Error)
   2. 503:表示服务器暂时处于超负载或正在进行停机维护(Service Unavailable)

## 常见的请求报头

- Accept: 表示客户端支持的数据格式,或者说客户端"希望"接收到的内容类型
- Accept-Encoding: 表示客户端所支持的解码格式
- Accept-Charset:表示客户端可接受的字符集
- Accept-Language:表示客户端可接受的语言
- Authoriztion: 主要用于证明客户端有权查看某个资源
- Host:用户指定被请求资源的 Internet 主机和端口号
- User-Agent:表示用户所使用的浏览器名称和版本和当前机器的信息
- Referer: 表示当前请求是从哪个资源发起的,或者是请求的上一步的地址.通常用于网站的访问统计,因为我们可以知道当前网站的是由哪个网站跳转过来的.
- If-Modified-Since: 表示客户端缓存文件的时间,客户端读取字段值,判断服务器端文件的最后修改时间,如果不晚于该值,则说明浏览器缓存的文件是最新的,然后就不会重新发送文件内容,而是将相应报文的状态设置为 304,表示浏览器可以继续使用缓存的文件,达到节省带宽的目的
- If-None-Match:该字段同 If-Modified-Since 字段一样,都用来表示自愿文件是否是最新的.只不过 If-Match-Since 表示文件的最后修改时间。Last-Modified/If-Modified-Since 和 Etag/If-None-Match 这两对头字段都是用来标记缓存资源的,并且后者的优先级要高于前者
- Cache-Control: 字面意思为"缓存-控制",前面的几个字段表明客户端/服务器如何使用缓存机制,而这个字段就是用来控制缓存的
  1. no-store ；表示浏览器不需要缓存本次的内容(*优先级比 Etag 和 Last-Modified 高*)
  2. max-age : 表示接下来的时间内,浏览器可以自主使用缓存内容,不需要想服务器发送同意的请求
  3. no-cache : 表示如果返回给我缓存文件时,需要向服务器进行确认,缓存是不是最新的

## 常见的响应报头

- Content-Length:表示接收到的响应报文的总长度
- Content-Type:响应正文的类型
- Content-Encoding:响应正文的数据压缩格式
- Content-Charset:响应正文的编码
- Content-Length:响应正文的长度
- Server:服务器名称
- Accept-Ranges:服务器所支持的内容范围
- Cache-Control:通知从服务器到客户端内的所有缓存机制,表示他们可以缓存这个对象的有效时间,单位秒
- Date:词条消息被发送的日期和时间
- ETag:某个资源的某个特定版本的标识符
- Expires：指定一个日期/时间,超过该时间则认为此回应已经过期
- Last-Modified:锁清秋的对象的最后修改日期
- Set-Cookie:设置 Cookie
## HTTP/1.x
### 缺陷
1. 链接无法复用:导致每次请求都经历三次握手和慢启动  
    1. HTTP/1.0传输数据是,每次都需要冲洗简历链接,增加延迟
    2. HTTP/1.1虽然加入了keep-alive可以复用一部分链接,但在某种情况下仍然需要建立多个connection,耗费资源,给服务器带来性能压力
2. 栈首阻塞(*Head-Of-Line Blocking(HOLB)*):当页面需要请求很多资源的时候,只有当之前的资源处理完毕之后,后续的资源才会开始发起请求
    1. HTTP/1.0:下个请求必须在前一个请求返回后才能发出,请求跟响应按序发生,如果某个请求长时间没有返回,那么接卸来的请求全部阻塞
    2. HTTP/1.1:尝试使用pipeling(管道化)来解决,即浏览器可以一次性发出多个请求(同域名,同TCP链接).但pipeline返回是按序的,如果某个请求很耗时,后续的其他请求即使已经处理完成,仍然需要等待前面的请求处理完成才开始返回(只部分解决了HOLB)
3. 协议开销大:HTTP/1.x在使用时,header携带了大量基本没有变化的内容,在一定程度上增加了传输的成本
4. 安全因素: HTTP/1.x在传输数据时,所以传输内容都是明文,客户端和服务器无法验证对方的身份,在一定程度上无法保证数据的安全性
## HTTP/2
1. 主要目标是通过支持完整的请求与响应复用来减少延迟,通过有效压缩HTTP表头字段将协议开销降至最低,同时增加对请求优先级和服务器推送的支持.*新的流控制、错误处理和升级机制*
2. HTTP/2没有改动HTTP的应用语义*HTTP方法、状态码、URI和标头字段一如往常*
3. HTTP/1.x使用的是文本来进行传输数据.HTTP/2引入了一个新的二进制分帧层(就是使用二进制格式来传输数据),无法与之前的HTTP/1.x服务器和客户端向后兼容,因此协议的主版本提升到HTTP/2
4. 多路复用: HTTP/2引入了多路复用的技术,解决了浏览器限制同一个域名下的请求数量问题
5. Header压缩
## HTTP/3

> 参考
- [HTTP/2,HTTP/3特性](https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/)
- [HTTP/2简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)
- [http报文](https://blog.csdn.net/qq_31869107/article/details/89339626)