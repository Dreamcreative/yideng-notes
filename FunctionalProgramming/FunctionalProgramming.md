# 函数式编程
函数式编程式是范畴论的数学分支,是一门很复杂的数学。范畴论认为,同一个范畴的所有成员就是不同状态的"变形"("态射").通过"态射“,一个成员可以变形成另一个成员
1. 函数是"第一等公民"
2. 只用"表达式"，"不用语句"
3. 没有"副作用"
4. 不修改状态
5. 引用透明(函数运行只靠参数)
## 内容
1. 所有成员是一个集合
2. 变形(态射)关系是函数
## 基础理论
1. 基础模型来源于 (lambda x=>x*2) 
2. 函数式编程不是用函数来编程,也不是传统的面向过程编程。主旨在于将复杂的函数复合成简单的函数.
3. 真正的火热是随着React 的高阶函数而逐步升温
## 常用核心概念
1. 纯函数
    1. 对于相同的输入,永远会得到相同的输出,而且没有任何可观察的副作用,也不依赖外部环境的状态
    纯函数 : Array.slice()
    2. 纯函数不仅可以有效降低系统的复杂度,还有其他特性,比如可缓存性 
2. 偏应用函数、函数的柯里化
    1. 传递给函数一部分参数来调用它,让他返回一个函数去处理剩下的参数
    2. 偏函数之所以"偏",就在于其职能处理那些能至少匹配一种情况下的输入,而不能处理所以可能的输入(switch case .就是一次只处理一种case)
        var _bind = fn.bind(null,2,3),bind就是一种函数柯里化
    3. 柯里化 通过偏应用函数实现.传递给函数一部分参数来调用它,让他返回一个函数去处理剩下的参数
    ```
    function foo(p1,p2){
        this.val = p1+p2;
    }
    var bar = foo.bind(null ,"p1");
    var baz = new bar("p2")
    console.log(baz.val)
    ```
    4. 柯里化是一种"预加载"函数的方法,通过传递较少的参数,得到一个已经记住了这些参数的新函数,某种意义上讲,这是一种对参数的"缓存", 是一种非常搞笑的编写函数的方法
3. 函数组合
4. point free
    存储中间逻辑,减少毫无意义的变量
5. 声明式与命令式代码
    1. 命令式: 通过编写一条又一条指令去执行一些动作,会设计到很多繁杂的细节
    2. 声明式 : 通过写表达式的方式来声明我们想干什么,而不是通过一步一步的指示(使用的函数必须是纯函数)
    ```
    //命令式
    let ceo = [];
    for(var i =0;i<10;i++>){
        ceo.push(i)
    }
    //声明式
    let ceo=arr.map(item=>item.ceo)
    ```
6. 惰性求值
7. 高阶函数
函数当参数,吧传入的函数做一个封装,然后返回之歌封装函数,达到更高程度的抽象
```
//命令式
var add= function(a,b){
    return a+b;
}
function math( fn , array){
    return fn(array[0],array[1])
}
math(add,[1,2])
```
1. 它是一等公民
2. 它已一个函数作为参数
3. 以一个函数作为返回结果
8. 尾调用优化PTC
浏览器并没有实现尾调用优化。只函数内部的最后一个动作是函数调用.该调用的返回值,直接返回给函数.函数调用自身,称为递归.如果尾调用自身,就称为尾调用自身，递归需要保存大量的调用记录,很容易 发生栈溢出错误,如果使用尾递归优化,将递归变为循环,那么只需要保存一个调用记录,这样就不会发生栈溢出错误。
开启尾递归调用优化方法 (浏览器实现了尾递归调用优化,但是需要手动开启)
```
//传统递归  //5个调用栈
function sum(x){
    if(x===1){
        return 1;
    }
    return x + sum(n-1);
}
sum(5); 
<!-- 
依次顺序
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2+sum(1)))))
(5 + (4 + (3 + (2+1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15
 -->
 //尾递归 一个调用栈
function sum(x,total){
    if(x===1){
        return x + total;
    }
    return sum(x-1, x + total);
}
sum(5);
<!-- 
调用顺序
sum(5,0) 
sum(4,5) 
sum(3,9) 
sum(2,12) 
sum(1,14)
15 
-->
```
1. return continue
2. !return 
3. #function()
尾递归问题:
1. 尾递归的判断标准是函数运行[最后一步]是否调用自身,而不是是否在函数的[最后一行]调用自身,最后一行调用其他函数并返回胶尾调用
2. 尾递归调用,调用栈永远都是更新当前的栈帧而已,这样就完全避免了爆栈的危险.现如今浏览器并未完全支持原因有二
    1. 在引擎层面消除递归是一个隐式的行为,程序员意识不到
    2. 堆栈信息丢失了,开发者难以调试(下面代码,如果bar中抛出了错误,在foo中被捕获了,)
    ```
        function foo(n){
            return bar(n*2);
        }
        function bar(){
            //查看调用帧
            console.trace();
        }
        foo(1)
    ```
    3. 浏览器不支持我们可以吧这些递归写成while (开发时,将能写成while的递归写成while)
9. 闭包
保存了当前作用域的词法作用域
10. 容器,Functor(函子)
容器: 只包含值,而没有其他的变形关系,当一个容器拥有了一种可以将一种容器转为另一个容器的变形关系时,容器就变成了函子(Functor)
函子(Functor): 可以接受值和一种变形关系,将当前容器变形成另一个容器
11. 错误处理、Euther、AP
12. IO
13. Monad